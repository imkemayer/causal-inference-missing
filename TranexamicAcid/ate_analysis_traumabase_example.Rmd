---
title: "Treatment Effect of Tranexamic Acid on TBI patients"
author: "Imke Mayer"
date: ""
output: 
  html_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 4
    toc_float: yes
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache= TRUE)
```


In this R markdown we analyze the Traumabase Registry to estimate the treatment
effect of the drug Tranexamic Acid (TXA) on mortality among patients with
traumatic brain injury (TBI).

For this analysis, an expert committee has identified 17 confounders available
in the Traumabase: `Trauma.center`, `Cardiac.arrest.ph`, 
`SBP.ph.min, DBP.ph.min, HR.ph.max`, `SBP.ph, DBP.ph, HR.ph`, 
`Shock.index.ph` (`HR.ph`/`SBP.ph`), `Cristalloid.volume`, `Colloid.volume`, 
`SpO2.ph.min`, `Vasopressor.therapy`, `HemoCue.init`, `Delta.hemoCue`, 
`AIS.external`, `Activation.HS.procedure`.


# Preliminaries

## Load libraries

```{r load_libraries, results='hide'}
library(cobalt)
library(ggplot2)
library(dplyr)
library(reshape2)
library(tableone)
library(MASS)
library(pracma)
library(assertthat)

library(caret) # 
library(ranger)# Random Forests prediction
library(FactoMineR) # Factorial data analysis
library(grf) # Doubly robust treatment effect estimation

library(norm)
library(missMDA) # PCA/MCA with missing values + iterative PC imputation
library(mice) # Multiple imputation
library(VIM) # Missing values exploration and visualization

# Define data directory
data.dir <- "~/Documents/TraumaMatrix/CausalInference/AcideTranexamique/Data/"
rdata.dir <- "~/Documents/TraumaMatrix/CausalInference/Simulations/causal-inference-missing/TranexamicAcid/RData/"
fig.dir <- "~/Documents/TraumaMatrix/CausalInference/Simulations/causal-inference-missing/TranexamicAcid/Figures/"

library(devtools)
# Load the ATE estimation functions `ipw` and `dr` from the GitHub repository
source_url("https://raw.githubusercontent.com/imkemayer/causal-inference-missing/master/Helper/helper_causalInference.R")
source_url("https://raw.githubusercontent.com/imkemayer/causal-inference-missing/master/Helper/helper_imputation.R")

save_results <- FALSE
tau <- NULL
# Set random generator seed for reproducible results
set.seed(0)
```

```{r ggplot_details, echo=F, warning=F, message=F}
library(RColorBrewer) # Color scale
myColors <- brewer.pal(6,"Set1")
names(myColors) <- c("-", "pc.imp", "mf", "mia", "mice", "mean")
myColorsATE <- c("black", "cyan")
names(myColorsATE) <- c("ATE true", "ATE naive")
colScale <- scale_colour_manual(name = c("", ""), values = c(myColors, myColorsATE))
```

## Load data
Run R markdown `preprocess_ate_analysis_traumabase_example.Rmd` prior to this to pre-process 
and save the data for the following analyses.
```{r load_data_for_ate}
data_indTBI <- read.csv(paste0(data.dir, 
                               "ate_analysis_traumabase_large_data_preprocessed_tbi_individuals.csv"), 
                        row.names = 1)
seed <- 1234
```

```{r rename_data}
synthetic <- FALSE

X.na <- data_indTBI[,setdiff(colnames(data_indTBI), 
                          c("TBI", "Tranexamic.acid", "Death"))]

W <- data_indTBI$Tranexamic.acid
Y <- data_indTBI$Death

covariate_names <- colnames(X.na)
n <- dim(X.na)[1]
p <- dim(X.na)[2]

df.na <- data.frame(cbind(X.na, W=W, Y=Y))
colnames(df.na) <- c(covariate_names, "W", "Y")
```

This pipeline requires `W` to be binary and coded either with `{0,1}` or with 
`{FALSE,TRUE}`, representing `{control,treatment}`.
```{r check_types}
assert_that(length(unique(W))==2)
assert_that(unique(W) %in% c(0,1) || unique(W) %in% c(FALSE,TRUE))
```

In certain cases, not all covariates are necessarily confounders. Therefore we 
specify the set of confounders in `confounder_names`. 
Additionally, in some cases there are also variables that are only predictive of 
the treatment assignment. Their names can be specified in `only_treatment_pred_names`.
```{r, confounders}
confounder_names <- c("Trauma.center", 
                      "SBP.ph", "DBP.ph", "HR.ph", 
                      "SBP.ph.min", "DBP.ph.min", "HR.ph.max",  
                      "Cardiac.arrest.ph", "Vasopressor.therapy", "SpO2.ph.min",
                      "AIS.external", "HemoCue.init", "Delta.hemoCue", 
                      "Shock.index.ph", "Cristalloid.volume", "Colloid.volume", 
                      "Activation.HS.procedure")
only_treatment_pred_names <- c()
only_outcome_pred_names <- setdiff(covariate_names, 
                                   c(confounder_names, only_treatment_pred_names))
```

For the DR estimation, we can specify clusters, here we will use the Trauma centers
as clusters.
```{r clusters}
cluster_names <- c("Trauma.center")
```

We list binary and other categorical variables to ensure correct type casts.
```{r specify_types}
binary_names <- intersect(covariate_names,
                          c("Cardiac.arrest.ph", "Anticoagulant.therapy", 
                            "Antiplatelet.therapy", "EVD", "Activation.HS.procedure",
                            "Neurosurgery.day0", "Fi02", "Vasopressor.therapy"))

categorical_names <- intersect(covariate_names,
                               c("Trauma.center", "Pupil.anomaly", 
                                 "Osmotherapy", "Osmotherapy.ph",
                                 "Pupil.anomaly.ph",
                                 "Improv.anomaly.osmo"))
```

It is possible that during the loading of the data set, certain 
variables are not cast correctly. We check that the variable types are all correct
according to the specified types in `binary_names` and `categorical_names`.
```{r check_types_raw, echo=F}
for (variable in binary_names) {
  if (!is.factor(X.na[, variable])) {
    X.na[, variable] <- as.factor(X.na[, variable])
    levels(X.na[, variable]) <- c(FALSE, TRUE)
  }
}
for (variable in categorical_names) {
  if (!is.factor(X.na[, variable])) {
    X.na[, variable] <- as.factor(X.na[, variable])
  }
}

df.na <- data.frame(cbind(X.na, W=W, Y=Y))
colnames(df.na) <- c(covariate_names, "W", "Y")
```


Look at the `Activation.HS.procedure` variable. The treatment TXA is generally 
given to prevent the occurrence of hemorrhagic shock, a condition which is often 
fatal. Let us see how is the treatment distributed w.r.t. this variable.

```{r hs_procedure}
res.table <- table(df.na$W==1, df.na$Activation.HS.procedure, 
                   dnn = c("Treated","Activation.HS.procedure"),
                   useNA = "ifany")
print(res.table)
```


First we compute the unadjusted ATE, ignoring the confounders.

```{r unadjusted_ate}
ate_raw <- mean(Y[which(as.logical(W))]) - mean(Y[which(!as.logical(W))])
```

Let us also assess how the outcome is distributed with respect to the treatment group.

```{r} 
if (length(unique(Y))==2){
  res.table <- table(as.factor(W), as.factor(Y), 
                     dnn = c("W","Y"))
  prop.table(res.table)
} else {
  ggplot(data.frame(W=as.factor(W), Y=Y)) + 
    geom_histogram(aes(Y, color=W), fill = "white")
}
```

Among the treated and the control most patients survived. But proportionally, 
more patients died in the treated group than in the control group. Strong 
indication for confounding factors that need to be controlled for.

From these two variables we can compute the following observed probabilities:

```{r raw_probabilities}
sprintf("Average outcome: %2.1f", mean(Y))
sprintf("P(Treatment=1) : %.2f", mean(W==1))
sprintf("E(Y | Treatment=1) : %.2f", mean(Y*(W==1))/mean(W==1))
sprintf("E(Y | Treatment=0) : %.2f", mean(Y*(W==0))/mean(W==0))
sprintf("ATE without adjustment : %.4f", ate_raw)
```

These uncorrected empirical quantities suggest that the treatment has a negative 
impact on the chances of survival. 

However, treated patients tend to have lower `Glasgow.initial` - and are 
therefore potentially more severe since according to the practitioners this 
covariate is a predictor for the patient's severity - which highly suggests that 
the treatment is not given uniformely at random.


```{r gcs_init, warning=F}
ggplot(data = data.frame(X.na, W=as.factor(W))) +
  geom_density(aes(x=GCS.init, color = W, fill = W), alpha = .2) 
```


# Imputation

We impute the data with two different methods (iterative FAMD, mice).

## FAMD

*Note that for this approach, an alternative would be to go back to the original 
dataset, instead of focusing just on the patients with TBI and/or `AIS.head >= 2` 
to impute the missing data. Even though we will only keep the patients with TBI 
and/or `AIS.head>=2` while running the causal analysis, including the other 
patients at this stage can allow the imputation of missing data to be more 
informed by adding additional observations for comparison purposes.*

Let's look at the matrix plot to identify if there are any variables that tend 
to be missing together or if we can detect any clear violation of the missing 
completely at random hypothesis:

```{r matrixplot}
matrixplot(df.na, sortby = 1, las=2, cex.axis = 0.3)
```


We can also run MCA on the missing and non missing entries to double check our 
conclusion and to check if other groups of variables tend to be missing together:
```{r }
data_miss <- data.frame(is.na(df.na))
data_miss <- apply(X=data_miss, FUN=function(x) if(x) "m" else "o", MARGIN=c(1,2))
res.mca <- MCA(data_miss, graph = FALSE)
plot(res.mca, invis = "ind", title = "MCA graph of the categories", cex =0.5)
```



We now perform a single imputation with a (regularized) iterative Factorial 
Analysis for Mixed Data model, which will allow imputation to take into account 
similarities between both individuals and relationships between variables. See: 
https://arxiv.org/pdf/1301.4797.pdf

First we find the optimal number of dimensions for the FAMD by cross-validation

**Attention: this computation might take a long time. Set `eval=F` in the chunk
header if you want to skip this part.** 
```{r ncomp_all}
if (file.exists(paste0(rdata.dir, "traumabase_tbi_ncomp_famd.RData"))) {
  load(paste0(rdata.dir, "traumabase_tbi_ncomp_famd.RData"))
  plot(1:length(ncomp_famd$criterion), ncomp_famd$criterion, xlab = "nb dim", ylab = "MSEP")
} else {
  ncomp_famd <- estim_ncpFAMD(df.na,
  ncp.min = 1,
  ncp.max=15,
  method= "Regularized",
  method.cv = "Kfold",
  nbsim=10,
  verbose = TRUE)

  save(ncomp_famd,
       file = paste0(rdata.dir, "traumabase_tbi_ncomp_famd.RData"))
}
```


By cross-validation we find `ncp=6` to be the optimal number of components.

```{r famd_impute}
# Recode values of imputed categorical variables and recast some numericals variables into integers 
cast_types = function(i,df, data.num){
  if (is.factor(df[,i])){
    df[,i] = plyr::mapvalues(df[,i], from = levels(df[,i]), to = gsub(paste(i,"_",sep=''), "", levels(df[,i])))
  } else {
    if(i %in% data.num){
      df[,i] <- round(df[,i],digits=1)
    }  else{
      df[,i] <- as.integer(round(df[,i],digits=0))
    }
  }
  return(df[,i])
}


if (file.exists(paste0(rdata.dir, "traumabase_tbi_", length(confounder_names), 
                       "confounders_", length(covariate_names), 
                       "variables_imputed_famd.RData"))){
  load(file=paste0(rdata.dir, "traumabase_tbi_", length(confounder_names), 
                       "confounders_", length(covariate_names), 
                       "variables_imputed_famd.RData"))
} else {
  ncp <- 6
  df.tmp <- data.frame(X.na, W = as.factor(W), Y = Y)
  colnames(df.tmp) <- colnames(df.na)
  df.imp.pc <- data.frame(imputeFAMD(df.tmp, ncp=ncp, seed=seed)$completeObs)
  
  data.num <- colnames(df.imp.pc)[which(sapply(df.tmp, FUN=function(x) (is.numeric(x) & !(is.integer(x)))))]
  for (j in colnames(df.imp.pc)){
    df.imp.pc[,j] <- cast_types(j, df.imp.pc, data.num)
  }
   
  levels(df.imp.pc$W) <- c(0,1)
  df.imp.pc$W <- as.numeric(as.character(df.imp.pc$W))
  
  save(df.imp.pc, file=paste0(rdata.dir, "traumabase_tbi_", 
                              length(confounder_names), 
                              "confounders_", length(covariate_names), 
                              "variables_imputed_famd.RData"))

}
```


It is possible that during the loading of the imputed data set, certain 
variables are not cast correctly. We check that the variable types are all correct
according to the specified types in `binary_names` and `categorical_names`.
```{r check_types_famd, echo=F}
for (variable in binary_names) {
  if (!is.factor(df.imp.pc[, variable]) & length(unique(df.imp.pc[, variable]))==2) {
    df.imp.pc[, variable] <- as.factor(df.imp.pc[, variable])
    levels(df.imp.pc[, variable]) <- c(FALSE, TRUE)
  }
}
for (variable in categorical_names) {
  if (!is.factor(df.imp.pc[, variable])) {
    df.imp.pc[, variable] <- as.factor(df.imp.pc[, variable])
  }
}
```


## MICE

We also prepare a multiple imputation analysis, using the `mice` package. 
We impute the data `m=5` times.

```{r mice_impute}
if (file.exists(paste0(rdata.dir, "traumabase_tbi_", length(confounder_names), 
                       "confounders_", length(covariate_names), 
                       "variables_imputed_mice.RData"))) {
  load(file=paste0(rdata.dir, "traumabase_tbi_", length(confounder_names), 
                       "confounders_", length(covariate_names), 
                       "variables_imputed_mice.RData"))
} else {
  m=5
  imp.mice.mids <- mice(df.na, m=m, seed=seed, printFlag=F)
  df.imp.mice <- list()
  for (k in 1:m){
    df.imp.mice[[k]] <- mice::complete(imp.mice.mids, k)
  }
  save(df.imp.mice, imp.mice.mids, file=paste0(rdata.dir, "traumabase_tbi_", 
                                length(confounder_names), "confounders_", 
                                length(covariate_names), 
                                "variables_imputed_mice.RData"))
}
```

Again we check and correct the variable types.
```{r check_types_mice, echo=F}
for (variable in binary_names) {
  for (k in 1:length(df.imp.mice)){
    if (!is.factor(df.imp.mice[[k]][, variable]) & length(unique(df.imp.mice[[k]][, variable]))==2) {
      df.imp.mice[[k]][, variable] <- as.factor(df.imp.mice[[k]][, variable])
      levels(df.imp.mice[[k]][, variable]) <- c(FALSE, TRUE)
    }
  }
}
for (variable in categorical_names) {
  for (k in 1:length(df.imp.mice)){
    if (!is.factor(df.imp.mice[[k]][, variable])) {
      df.imp.mice[[k]][, variable] <- as.factor(df.imp.mice[[k]][, variable])
    }
  }
}
```


# ATE estimation

We are interested in estimating the causal effect of TXA on the mortality of 
TBI patients.

Although most of the patients receive multiple treatments (in pre-hospital and 
hospital phase) and we have records of these other treatments (for instance 
osmotherapy, fibrinogene, etc.) we are only considering the effect of TXA on 
in-hospital mortality.




## IPW

### On imputed data
```{r ipw_ate, warning=FALSE, echo=F}
results_ipw_imp_list <- list()
results_ipw_imp <- data.frame(matrix(ncol=7, nrow=0), row.names = NULL)
colnames(results_ipw_imp) <- c("Estimand",
                               "Imputation.method", 
                               "PS.estimation",
                               "Mask",
                               "ATE.normalized", 
                               "STD.ATE.normalized",
                               "ATE.unnormalized")

data_list <- list(list("pc.imp", df.imp.pc),
                  list("mice", df.imp.mice))

methods_list <- list("glm", "grf.ate")

weights_list <- list("all", "treated", "control", "overlap")
weights_trim_list <- list(0.999, 0.999, 0.999, 1)
estimands_list <- list("ATE", "ATT", "ATC", "ATE_overlap")

idx <- 1

for (use.mask in c(FALSE, TRUE)){
  for (l in 1:length(weights_list)){
    for (i in 1:length(data_list)){
      if (data_list[[i]][[1]]=="mice"){
        confounders <- list()
        mask <- NULL
        outcome <- treatment <- list()
        if (use.mask) mask <- list()
        for (k in 1:length(data_list[[i]][[2]])){
          confounders[[k]] <- data_list[[i]][[2]][[k]] %>% 
                                dplyr::select(c(only_treatment_pred_names, confounder_names))
    
  
          if (use.mask){
            mask[[k]] <- is.na(X.na[, c(only_treatment_pred_names, confounder_names)])
            mask[[k]] <- mask[[k]][,sapply(data.frame(mask[[k]] ), FUN = function(x) length(unique(x))==2)]
          }
        }
        
      }
        
      else {
        confounders <- data_list[[i]][[2]] %>% 
                          dplyr::select(c(only_treatment_pred_names, confounder_names))
        
        mask <- NULL
        if (use.mask){
          mask <- is.na(X.na[, c(only_treatment_pred_names, confounder_names)])
          mask <- mask[,sapply(data.frame(mask), FUN = function(x) length(unique(x))==2)]
        }
       }
      
      
      
      for (j in 1:length(methods_list)){
        if (data_list[[i]][[1]]== "mice"){
          tmp <- c()
          for (k in 1:length(data_list[[i]][[2]])){
            tmp <- rbind(tmp, ipw(X=confounders[[k]], outcome = Y, treat = as.logical(W),
                                  mask = mask[[k]],
                                  ps.method = methods_list[[j]], 
                                  target = weights_list[[l]], 
                                  seed=seed, 
                                  trimming_weight=weights_trim_list[[l]]))
          }
          tmp[,3] <- tmp[,3]^2*n
          results_ipw_imp_list[[idx]] <- apply(tmp, 2, mean)
          results_ipw_imp_list[[idx]][[3]] <- sqrt(results_ipw_imp_list[[idx]][[3]] +
                                                (1+ 1/length(data_list[[i]][[2]]))*sum((tmp[,2] - results_ipw_imp_list[[idx]][[2]])^2)/(length(data_list[[i]][[2]])-1))/sqrt(n)
          
        }
        else {
          results_ipw_imp_list[[idx]] <- ipw(X=confounders, outcome = Y, treat = as.logical(W),
                                             mask = mask,
                                             ps.method = methods_list[[j]], target = weights_list[[l]], 
                                             seed=seed, trimming_weight=weights_trim_list[[l]])
          
        }
        results_ipw_imp <- rbind(results_ipw_imp,
                                   data.frame("Estimand" = estimands_list[[l]],
                                              "Imputation.method" = data_list[[i]][[1]],
                                              "PS.estimation" = methods_list[[j]],
                                              "Mask" = use.mask,
                                              "ATE.normalized" = results_ipw_imp_list[[idx]][[2]],
                                              "STD.ATE.normalized" = results_ipw_imp_list[[idx]][[3]],
                                              "ATE.unnormalized" = results_ipw_imp_list[[idx]][[1]]))
        idx <- idx+1
      }
    }
  }
}

knitr::kable(results_ipw_imp, caption = "IPW estimations", digits = 2)
```

### MIA+grf
```{r ipw_at_mia, warning=FALSE, echo=F}
results_ipw_mia_list <- list()
results_ipw_mia <- data.frame(matrix(ncol=7, nrow=0), row.names = NULL)
colnames(results_ipw_mia) <- c("Estimand",
                               "Imputation.method", 
                               "PS.estimation", 
                               "Mask",
                               "ATE.normalized", 
                               "STD.ATE.normalized",
                               "ATE.unnormalized")



weights_list <- list("all", "treated", "control", "overlap")
weights_trim_list <- list(0.999, 0.999, 0.999, 1)
estimands_list <- list("ATE", "ATT", "ATC", "ATE_overlap")

    
idx <- 1

for (use.mask in c(TRUE)){
  for (k in 1:length(weights_list)){
    confounders <- X.na %>%
              dplyr::select(c(only_treatment_pred_names, confounder_names))
    
    mask <- NULL
    if (use.mask){
      mask <- is.na(X.na[, c(only_treatment_pred_names, confounder_names)])
    }
    
    results_ipw_mia_list[[idx]] <- ipw(X=confounders, ps.method="grf.ate", 
                                       mask=mask,
                                       treat=as.logical(W), outcome=Y, 
                                       target=weights_list[[k]], 
                                       seed=seed, 
                                       trimming_weight=weights_trim_list[[k]])
       
        
    results_ipw_mia <- rbind(results_ipw_mia,
                              data.frame("Estimand" = estimands_list[[k]],
                                         "Imputation.method" = "mia",
                                         "PS.estimation" = "grf.ate",
                                         "Mask" = use.mask,
                                         "ATE.normalized" = results_ipw_mia_list[[idx]][[2]],
                                         "STD.ATE.normalized" = results_ipw_mia_list[[idx]][[3]],
                                         "ATE.unnormalized" = results_ipw_mia_list[[idx]][[1]]))
        
    idx <- idx+1
  }
}

knitr::kable(results_ipw_mia, caption = "ipw ATE estimations on mia covariates", digits = 2)
```


## DR

### On imputed data

```{r dr_imp, warning=F, echo=F}
results_dr_imp_list <- list()
results_dr_imp <- data.frame(matrix(ncol=6, nrow=0), row.names = NULL)
colnames(results_dr_imp) <- c("Estimand",
                              "Imputation.method", 
                              "PS.estimation",
                              "Mask",
                              "ATE", 
                              "STD")

data_list <- list(list("pc.imp", df.imp.pc),
                  list("mice", df.imp.mice))

methods_list <- list("glm.grf", "grf.ate")

weights_list <- list("all", "treated", "control", "overlap")
weights_trim_list <- list(0.999, 0.999, 0.999, 1)
estimands_list <- list("ATE", "ATT", "ATC", "ATE_overlap")

idx <- 1

for (use.mask in c(FALSE, TRUE)){
  for (l in 1:length(weights_list)){
    for (i in 1:length(data_list)){
      if (data_list[[i]][[1]]=="mice"){
        confounders <- treatment_regressors <- outcome_regressors <- clusters <- list()
        mask.confounders <- mask.treatment_regressors <- mask.outcome_regressors <- NULL
        if (use.mask) mask.confounders <- mask.treatment_regressors <- mask.outcome_regressors <-list()
        for (k in 1:length(data_list[[i]][[2]])){
          confounders[[k]] <- data_list[[i]][[2]][[k]] %>% 
                                dplyr::select(confounder_names)
          treatment_regressors[[k]] <- data_list[[i]][[2]][[k]] %>% 
                                dplyr::select(c(only_treatment_pred_names,confounder_names))
          outcome_regressors[[k]] <- data_list[[i]][[2]][[k]] %>% 
                                dplyr::select(c(only_outcome_pred_names,confounder_names))
          if (length(cluster_names)>0) {
            clusters[[k]] <- data_list[[i]][[2]][[k]] %>% 
                                dplyr::select(cluster_names) %>%
                                apply(MARGIN=2, as.numeric)
          }
          
          if (use.mask){
            mask.confounders[[k]] <- is.na(X.na[,confounder_names])
            mask.treatment_regressors[[k]] <- is.na(X.na[c(only_treatment_pred_names, confounder_names)])
            mask.outcome_regressors[[k]] <- is.na(X.na[c(only_outcome_pred_names, confounder_names)])
            
            mask.confounders[[k]] <- data.frame(mask.confounders[[k]][,sapply(data.frame(mask.confounders[[k]]), FUN = function(x) length(unique(x))==2)])
            mask.treatment_regressors[[k]] <- data.frame(mask.treatment_regressors[[k]][,sapply(data.frame(mask.treatment_regressors[[k]]), FUN = function(x) length(unique(x))==2)])
            mask.outcome_regressors[[k]] <- data.frame(mask.outcome_regressors[[k]][,sapply(data.frame(mask.outcome_regressors[[k]]), FUN = function(x) length(unique(x))==2)])
          }
        }
      }
      
      else {    
        clusters <- NULL
        confounders <- data_list[[i]][[2]] %>% 
                            dplyr::select(confounder_names)
        treatment_regressors <- data_list[[i]][[2]] %>% 
                                dplyr::select(c(only_treatment_pred_names,confounder_names))
        outcome_regressors <- data_list[[i]][[2]] %>% 
                                dplyr::select(c(only_outcome_pred_names,confounder_names))
        clusters <- data_list[[i]][[2]] %>% 
                        dplyr::select(cluster_names) %>%
                        apply(MARGIN=2, as.numeric)
        mask.confounders <- mask.treatment_regressors <- mask.outcome_regressors <- NULL
        if (use.mask){
          mask.confounders <- is.na(X.na[,confounder_names])
          mask.treatment_regressors<- is.na(X.na[c(only_treatment_pred_names, confounder_names)])
          mask.outcome_regressors <- is.na(X.na[c(only_outcome_pred_names, confounder_names)])
            
          mask.confounders <- data.frame(mask.confounders[,sapply(data.frame(mask.confounders), FUN = function(x) length(unique(x))==2)])
          mask.treatment_regressors <- data.frame(mask.treatment_regressors[,sapply(data.frame(mask.treatment_regressors), FUN = function(x) length(unique(x))==2)])
          mask.outcome_regressors <- data.frame(mask.outcome_regressors[,sapply(data.frame(mask.outcome_regressors), FUN = function(x) length(unique(x))==2)])
        }
      }
      
      for (j in 1:length(methods_list)){
        if (data_list[[i]][[1]] == "mice"){
          tmp <- c()
          for (k in 1:length(data_list[[i]][[2]])){
            if (length(cluster_names)==0){
              cls <- NULL
            } else {
              cls <- clusters[[k]]
            }
            tmp <- rbind(tmp, dr(X=confounders[[k]], 
                                 X.for.ps = treatment_regressors[[k]],
                                 X.for.outcome = outcome_regressors[[k]],
                                 outcome = Y, treat = as.logical(W),
                                 mask = mask.confounders[[k]], 
                                 mask.for.ps = mask.treatment_regressors[[k]],
                                 mask.for.outcome = mask.outcome_regressors[[k]],
                                 ps.method = methods_list[[j]], 
                                 out.method = methods_list[[j]],
                                 target = weights_list[[l]], 
                                 seed=seed, 
                                 trimming_weight=weights_trim_list[[l]],
                                 clusters=cls)) 
          }
          tmp[,2] <- tmp[,2]^2*n
          results_dr_imp_list[[idx]] <- apply(tmp, 2, mean)
          results_dr_imp_list[[idx]][[2]] <- sqrt(results_dr_imp_list[[idx]][[2]] +
                                              (1+ 1/length(data_list[[i]][[2]]))*sum((tmp[,1] - results_dr_imp_list[[idx]][[1]])^2)/(length(data_list[[i]][[2]])-1))/sqrt(n)
        }
        else {
          results_dr_imp_list[[idx]] <- dr(X=confounders, 
                                           X.for.ps = treatment_regressors,
                                           X.for.outcome = outcome_regressors,
                                           outcome = Y, treat = as.logical(W),
                                           mask = mask.confounders, 
                                           mask.for.ps = mask.treatment_regressors,
                                           mask.for.outcome = mask.outcome_regressors,
                                           ps.method = methods_list[[j]], 
                                           out.method = methods_list[[j]],
                                           target = weights_list[[l]], 
                                           seed=seed, 
                                           trimming_weight=weights_trim_list[[l]],
                                           clusters=clusters)
        }
        results_dr_imp <- rbind(results_dr_imp,
                                 data.frame("Estimand" = estimands_list[[l]],
                                            "Imputation.method" = data_list[[i]][[1]],
                                            "PS.estimation" = methods_list[[j]],
                                            "Mask" = use.mask,
                                            "ATE" = results_dr_imp_list[[idx]][[1]],
                                            "STD" = results_dr_imp_list[[idx]][[2]]))
        
        idx <- idx+1
      }
    }
  }
}
knitr::kable(results_dr_imp, caption = "DR estimations", digits = 2)
```


### MIA+grf
```{r dr_at_mia, warning=FALSE, echo=F}
results_dr_mia_list <- list()
results_dr_mia <- data.frame(matrix(ncol=6, nrow=0), row.names = NULL)
colnames(results_dr_mia) <- c("Estimand",
                              "Imputation.method",
                              "PS.estimation",
                              "Mask",
                              "ATE", 
                              "STD")

weights_list <- list("all", "treated", "control", "overlap")
weights_trim_list <- list(0.999, 0.999, 0.999, 1)
estimands_list <- list("ATE", "ATT", "ATC", "ATE_overlap")

    
idx <- 1

for (use.mask in c(FALSE, TRUE)){
  for (k in 1:length(weights_list)){
    clusters <- NULL
    confounders <- X.na %>% 
                      dplyr::select(confounder_names)
    treatment_regressors <- X.na %>% 
                              dplyr::select(c(only_treatment_pred_names, confounder_names))
    outcome_regressors <- X.na %>% 
                            dplyr::select(c(only_outcome_pred_names, confounder_names))
    clusters <- X.na %>% 
                   dplyr::select(cluster_names) %>%
                   apply(MARGIN=2, as.numeric)
    mask.confounders <- mask.treatment_regressors <- mask.outcome_regressors <- NULL
    if (use.mask){
      mask.confounders <- is.na(X.na[,confounder_names])
      mask.treatment_regressors <- is.na(X.na[setdiff(c(only_treatment_pred_names,confounder_names), cluster_names)])
      mask.outcome_regressors <- is.na(X.na[setdiff(c(only_outcome_pred_names,confounder_names), cluster_names)])
        
      mask.confounders <- data.frame(mask.confounders[,sapply(data.frame(mask.confounders), FUN = function(x) length(unique(x))==2)])
      mask.treatment_regressors <- data.frame(mask.treatment_regressors[,sapply(data.frame(mask.treatment_regressors), FUN = function(x) length(unique(x))==2)])
      mask.outcome_regressors <- data.frame(mask.outcome_regressors[,sapply(data.frame(mask.outcome_regressors), FUN = function(x) length(unique(x))==2)])
    }
      
    results_dr_mia_list[[idx]] <- dr(X=confounders, 
                                     X.for.ps = treatment_regressors,
                                     X.for.outcome = outcome_regressors,
                                     outcome = Y, treat = as.logical(W),
                                     mask = mask.confounders, 
                                     mask.for.ps = mask.treatment_regressors,
                                     mask.for.outcome = mask.outcome_regressors,
                                     ps.method = "grf.ate", out.method = "grf.ate",
                                     target = weights_list[[k]], 
                                     seed=seed, 
                                     trimming_weight=weights_trim_list[[k]],
                                     clusters=clusters)
         
          
    results_dr_mia <- rbind(results_dr_mia,
                            data.frame("Estimand" = estimands_list[[k]],
                                       "Imputation.method" = "mia",
                                       "PS.estimation" = "grf.ate",
                                       "Mask" = use.mask,
                                       "ATE" = results_dr_mia_list[[idx]][[1]],
                                       "STD" = results_dr_mia_list[[idx]][[2]]))
    
    idx <- idx+1
  }
}

knitr::kable(results_dr_mia, caption = "DR ATE estimations on mia covariates", digits = 2)
```



# Results
## Plots

We will plot the results for the ATE estimation. Alternatively, you can also plot the
results for the other estimands (in the call of the function `plot_treatment_effect`, set `estimand` to `ATT`, `ATC` or `ATE_overlap`).


```{r function_plot_combined, echo=F}
plot_treatment_effect <- function(res_dr, res_ipw, estimand, ps.estimation=c("grf", "grf.ate"), 
                                  imputation.method=c("pc.imp","mice","mia"),
                                  mask=TRUE,
                                  y.min=NULL,
                                  y.max=NULL){ 
  results_dr_ate <- res_dr %>%
                       filter(Estimand == estimand & PS.estimation %in% ps.estimation &
                              Mask == mask &
                              tolower(Imputation.method) %in% imputation.method)

  results_dr_ate$CI.inf<- results_dr_ate$ATE - 1.96*results_dr_ate$STD
  results_dr_ate$CI.sup <- results_dr_ate$ATE + 1.96*results_dr_ate$STD


  results_ipw_ate <- res_ipw %>%
                       filter(Estimand == estimand & PS.estimation %in% ps.estimation &
                              Mask == mask &
                              tolower(Imputation.method) %in% imputation.method) 
  
  results_ipw_ate$ATE <- results_ipw_ate$ATE.normalized
  results_ipw_ate$STD <- results_ipw_ate$STD.ATE.normalized
  
  results_ipw_ate$CI.inf <- results_ipw_ate$ATE - 1.96*results_ipw_ate$STD
  results_ipw_ate$CI.sup <- results_ipw_ate$ATE + 1.96*results_ipw_ate$STD


  results_ipw_ate <- dplyr::select(results_ipw_ate, -c("ATE.normalized","ATE.unnormalized",
                                                       "STD.ATE.normalized"))

  results_ate <- rbind(cbind(results_dr_ate, "type"=rep("dr", dim(results_dr_ate)[1])),
                       cbind(results_ipw_ate,"type"=rep("ipw", dim(results_ipw_ate)[1])))
  results_ate$type <- as.factor(results_ate$type)

  results_ate$PS.estimation[which(results_ate$PS.estimation=="glm.grf")] <- "glm"
  
  if ("grf" %in% ps.estimation & !("glm" %in% ps.estimation)){
    levels(results_ate$PS.estimation) <- rep("grf.ate", length(levels(results_ate$PS.estimation)))
  }
  results_ate$Imputation.set <- interaction(results_ate$Imputation.method,
                                            results_ate$PS.estimation)

  df_plot <- results_ate[which(tolower(results_ate$Imputation.method) %in% imputation.method),]
  y.min <- min(c(y.min, ate_raw, df_plot$CI.inf), na.rm=T)
  y.min <- if_else(y.min<0, y.min*1.1, y.min*0.9)
  y.max <- max(c(y.max, ate_raw, df_plot$CI.sup), na.rm=T)
  y.max <- if_else(y.max<0, y.max*0.9, y.max*1.1)
  
  labels <- c("mia.grf.ate" = "MIA",
              "mice.grf.ate" ="MICE",
              "pc.imp.grf.ate" ="PC imputation",
              "mean.grf.ate" = "Mean imputation",
              "mf.grf.ate" = "Latent factors",
              "mice.glm" ="MICE",
              "pc.imp.glm" ="PC imputation",
              "mean.glm" = "Mean imputation",
              "mf.glm" = "Latent factors",
              "mice.glm.grf" ="MICE",
              "pc.imp.glm.grf" ="PC imputation",
              "mean.glm.grf" = "Mean imputation",
              "mf.glm.grf" = "Latent factors")
  plt <- ggplot(data=df_plot,
         aes(x=Imputation.set, y = ATE, color=Imputation.method)) +
         geom_errorbar(aes(ymin=CI.inf, ymax=CI.sup, linetype = type), width=0.8, size=1.8)
  if (estimand == "ATE") {
    plt <- plt + geom_hline(aes(yintercept = ate_raw, colour = "ATE naive"), linetype = "dashed", size = 1.8)
  }
  if (synthetic & estimand == "ATE" & !is.null(tau)) {
    plt <- plt + geom_hline(aes(yintercept=tau, colour="ATE true"), show.legend = T)
  } else {
    plt <- plt + geom_hline(aes(yintercept=0), colour="black", show.legend = F, size = 1.5)
  }
  plt <- plt + 
          coord_flip() +
          colScale +
          theme(axis.title=element_text(size=16),
                axis.text=element_text(size=18, face="bold"),
                legend.position="bottom",
                legend.box="vertical", legend.margin=margin(),
                legend.text=element_text(size=18, face="bold"),
                legend.title=element_text(size=16),
                axis.title.y=element_blank(),
                axis.text.y=element_blank(),
                axis.ticks.y=element_blank(),
                panel.background = element_rect(fill="white", colour="black", size=0.5, 
                                          linetype="solid")) +
          scale_x_discrete(labels = labels[which(names(labels) %in% df_plot$Imputation.set)],
                           limits = names(labels)[which(names(labels) %in% df_plot$Imputation.set)],
                           position="top") +
    xlab("") +
    ylab(estimand) +
    ylim(c(y.min,y.max)) +
    labs(title=paste0(estimand," estimation"), cex=0.7)
  
  return(plt)
}
```

```{r combine_results, echo=F, warning = F, message = F}
# Aggregate IPW results
results_ipw <- rbind(results_ipw_imp,
                     results_ipw_mia)

levels(results_ipw$Imputation.method) <- tolower(levels(results_ipw$Imputation.method))
 
# Aggregate DR results
results_dr <- rbind(results_dr_imp,
                    results_dr_mia) 

if (save_results) {
  save(results_ipw, results_dr, file=paste0(rdata.dir, Sys.Date(), "_results_ipw_dr.RData"))
}
levels(results_dr$Imputation.method) <- tolower(levels(results_dr$Imputation.method))
```


### ATE
```{r plot_ate, echo=F}
plt <- plot_treatment_effect(results_dr, results_ipw, "ATE", ps.estimation=c("glm", "glm.grf"), y.min=-0.05, y.max=0.58)
print("GLM") 
print(plt)  
ggsave(paste0(fig.dir,Sys.Date(),"_large_data_17confounders_ipw_dr_ate_glm.pdf"),
       plot = last_plot(),
       width=7, height=6) 

plt <- plot_treatment_effect(results_dr, results_ipw, "ATE", ps.estimation=c("grf", "grf.ate"), y.min=-0.05, y.max=0.58)
print("GRF")
print(plt)
ggsave(paste0(fig.dir,Sys.Date(),"_large_data_17confounders_ipw_dr_ate_grf.pdf"),
       plot = last_plot(),
       width=7, height=6) 
```


### ATT
```{r plot_att, echo=F}
plt <- plot_treatment_effect(results_dr, results_ipw, "ATT", ps.estimation=c("grf", "grf.ate"))
print(plt)

# ggsave(paste0(fig.dir,Sys.Date(),"_large_data_17confounders_ipw_dr_att_", population, "patients.pdf"),
#        plot = last_plot(),
#        width=11, height=8.5)
```

### ATC
```{r plot_atc, echo=F}
plt <- plot_treatment_effect(results_dr, results_ipw, "ATC", ps.estimation=c("grf", "grf.ate"))
print(plt)

# ggsave(paste0(fig.dir,Sys.Date(),"_large_data_17confounders_ipw_dr_atc_", population, "patients.pdf"), 
#        plot = last_plot(),
#        width=11, height=8.5)  
```

### ATE_overlap
```{r plot_ato, echo=F}
plt <- plot_treatment_effect(results_dr, results_ipw, "ATE_overlap", ps.estimation=c("grf", "grf.ate"))
print(plt)

# ggsave(paste0(fig.dir,Sys.Date(),"_large_data_17confounders_ipw_dr_ato_", population, "patients.pdf"), 
#        plot = last_plot(),
#        width=11, height=8.5)  
```


# Appendix
## Balance plots


The standardized mean differences (SMD) higher than some threshold `th`, 
for instance `th=0.1`, indicate that the covariate distributions in the two 
groups differ: the treatment is not given uniformly at random. 
This explains the need for some adjustment or balancing in order to perform a 
causal analysis of the treatment on a certain outcome.

Note: small SMDs do not necessarily indicate balanced treatment groups, indeed
the distributions can differ on other quantities than the first order.

We use propensity scores estimated via the function `regression_forest` of the
`grf` package.

### On `X.imp.pc`
```{r balance_overlap_famd-grf, echo=F}
X.m = model.matrix(~. , data=data.frame(df.imp.pc[, confounder_names]))
forest.W = regression_forest(X.m, as.logical(W), tune.parameters = "all")
w.hat = predict(forest.W, X.m)$predictions
weights = as.numeric(as.logical(W))/w.hat + (1-as.numeric(as.logical(W)))/(1-w.hat)

balance <- bal.tab(df.imp.pc[, covariate_names], treat = W, 
                   estimand="ATE", continuous="std", weights = weights, 
                   method = "weighting", un=TRUE)

love.plot(x = balance, stat = "mean.diffs", abs = TRUE, var.order = "unadjusted", 
          threshold = 0.1, cex=0.8, stars="raw", shapes=c("circle", "triangle"), colors=c(viridis::viridis(10)[3], viridis::viridis(10)[9]),)
```

We can also use the previously computed weights to look at the balance of the response pattern.
```{r balance_overlap_pc_mask-grf}
incomplete_confounders <- confounder_names[which(sapply(X.na[,confounder_names], 
                                                        function(x) sum(is.na(x))>0))]
R <- data.frame(is.na(X.na[,incomplete_confounders]))
colnames(R) <- paste(incomplete_confounders, "_NA", sep="")
balance <- bal.tab(R, treat=W, estimand="ATE", weights=weights, method = "weighting", un=TRUE)

love.plot(x=balance, stat="mean.diffs", abs=TRUE, var.order="unadjusted", 
          threshold=0.1, cex=0.8, shapes=c("circle", "triangle"), colors=c(viridis::viridis(10)[3], viridis::viridis(10)[9]),)

bal.plot(x=data.frame(treat=as.logical(W), ps=w.hat, weights=weights), var.name="ps", which="both",
         treat=as.logical(W),
         weights=weights,
         type="histogram", mirror=TRUE)
```


### On `X.imp.mice`
```{r balance_overlap_mice-grf, echo=F}
w.hat <- list()
weights <- list()
df.ps <- list()
for (k in 1:length(df.imp.mice)){
  df.ps[[k]] <- df.imp.mice[[k]][, confounder_names]
  X.m = model.matrix(~. , data=data.frame(df.ps[[k]]))
  forest.W = regression_forest(X.m, as.logical(df.imp.mice[[k]]$W), tune.parameters = "all")
  w.hat[[k]] = predict(forest.W, X.m)$predictions
  weights[[k]] = as.numeric(as.logical(df.imp.mice[[k]]$W))/w.hat[[k]] + (1-as.numeric(as.logical(df.imp.mice[[k]]$W)))/(1-w.hat[[k]])
}
balance <- list()
imputed_weighted <- list()
for (k in 1:length(df.imp.mice)){
  balance[[k]] <- bal.tab(df.imp.mice[[k]][,confounder_names], 
                          treat=df.imp.mice[[k]]$W,
                          weights=weights[[k]],
                          estimand="ATE", 
                          method = "weighting", un=TRUE)
  imputed_weighted[[k]] <- balance[[k]]$Balance[,c("Diff.Un", "Diff.Adj")]
}

for (k in 1:length(df.imp.mice)){
  plt <- love.plot(x = balance[[k]], stat = "mean.diffs", abs = TRUE, var.order = "unadjusted", threshold = 0.1, cex=0.8, 
                   stars = "raw", shapes=c("circle", "triangle"), colors=c(viridis::viridis(10)[3], viridis::viridis(10)[9]),)
  print(plt)
  
  plt <- bal.plot(x=data.frame(treat=as.logical(df.imp.mice[[k]]$W), ps=w.hat[[k]], weights=weights[[k]]), var.name = "ps", which = "both",
         treat=as.logical(df.imp.mice[[k]]$W),
         weights=weights[[k]],
         type = "histogram", mirror = TRUE)
  print(plt)
}

imputed_weighted_avg <- Reduce(`+`, imputed_weighted) / length(imputed_weighted)
imputed_weighted_avg$Variable <-row.names(imputed_weighted_avg)
imputed_weighted_avg <- imputed_weighted_avg %>%
                          arrange(abs(Diff.Un))
imputed_weighted_avg$Variable <- factor(imputed_weighted_avg$Variable, levels = imputed_weighted_avg$Variable)

#imputed_weighted_avg <- imputed_weighted_avg[-which(sapply(imputed_weighted_avg$Variable, function(x) grepl("<NA>", x, fixed=T))),]
ggplot(data=imputed_weighted_avg) + 
  geom_point(aes(x = Variable, y = abs(Diff.Un), shape="unadj"), color = viridis::viridis(10)[3], size=2.5) +
  geom_point(aes(x = Variable, y = abs(Diff.Adj), shape="adj"), color = viridis::viridis(10)[9], size=2.5) +
  scale_shape_manual(name="Sample",
                     values = c(unadj="circle", adj="triangle"),
                     labels = c("Adjusted","Unadjusted"))+
  geom_hline(yintercept = 0.1, linetype = "dashed", size=0.4) +
  geom_hline(yintercept = 0, size=0.4) +
  ylab("Absolute Mean Differences")+
  xlab("")+
  labs(title="Covariate Balance") +
  coord_flip() + 
  theme_minimal() + 
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        panel.background = element_rect(colour = "black", size=0.4),
        axis.text.y = element_text(color="black", size=9),
        axis.text.x = element_text(color="black"),
        axis.ticks = element_line(colour = "black", size = 0.2),
        axis.line = element_line(colour = 'transparent', size = 0.4),
        plot.title = element_text(size=13, hjust=0.5))
```



### On `X.na` using MIA
```{r balance_overlap_grf-mia, echo=FALSE}
na.action <- options()$na.action
options(na.action='na.pass')
X.m = model.matrix(~. , data=X.na[, confounder_names])
options(na.action=na.action)
forest.W = regression_forest(X.m, as.logical(W), tune.parameters = "all")
w.hat = predict(forest.W, X.m)$predictions
weights = as.numeric(as.logical(W))/w.hat + (1-as.numeric(as.logical(W)))/(1-w.hat)

bal.plot(x=data.frame(treat=as.logical(W), ps=w.hat, weights=weights), 
         var.name = "ps", which = "both",
         treat=as.logical(W),
         weights=weights,
         type = "histogram", mirror = TRUE)

balance <- bal.tab(X.na[, confounder_names], treat = W, estimand="ATE", continuous="std", weights = weights, method = "weighting", un=TRUE)
love.plot(x = balance, stat = "mean.diffs", abs = TRUE, var.order = "unadjusted", continuous="std", threshold = 0.1, cex=0.8, shapes=c("circle", "triangle"), colors=c(viridis::viridis(10)[3], viridis::viridis(10)[9]), stars = "raw")

balance <- bal.tab(R, treat = W, estimand="ATE", weights = weights, method = "weighting", un=TRUE)

love.plot(x = balance, stat = "mean.diffs", abs = TRUE, var.order = "unadjusted", threshold = 0.1, cex=0.8, shapes=c("circle", "triangle"), colors=c(viridis::viridis(10)[3], viridis::viridis(10)[9]), stars = "raw")
```


