---
title: "Example of ATE estimation with missing attributes"
author: "Imke Mayer"
output: 
  html_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 4
    toc_float: yes
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache= TRUE)
```




# Preliminaries

## Load libraries

```{r load_libraries, results='hide'}
suppressPackageStartupMessages(library(cobalt))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(reshape2))
suppressPackageStartupMessages(library(tableone))
suppressPackageStartupMessages(library(MASS))
suppressPackageStartupMessages(library(pracma))

suppressPackageStartupMessages(library(caret)) # 
suppressPackageStartupMessages(library(ranger)) # Random Forests prediction
suppressPackageStartupMessages(library(FactoMineR)) # Factorial data analysis
suppressPackageStartupMessages(library(grf)) # Doubly robust treatment effect estimation

suppressPackageStartupMessages(library(norm))
suppressPackageStartupMessages(library(missMDA)) # PCA/MCA with missing values + iterative PC imputation
suppressPackageStartupMessages(library(mice)) # Multiple imputation
suppressPackageStartupMessages(library(naniar)) # Missing values exploration and visualization
suppressPackageStartupMessages(library(VIM)) # Missing values exploration and visualization

suppressPackageStartupMessages(library(RColorBrewer)) # Color scale
myColors <- brewer.pal(6,"Set1")
names(myColors) <- c("-", "pc.imp", "mf", "mia", "mice", "mean")
myColorsATE <- c("black", "cyan")
names(myColorsATE) <- c("ATE true", "ATE naive")
colScale <- scale_colour_manual(name = c("", ""), values = c(myColors, myColorsATE))


# Set random generator seed for reproducible results
set.seed(0)

helper.dir <- "~/Documents/TraumaMatrix/CausalInference/Simulations/causal-inference-missing/"
source(paste0(helper.dir, "Helper/helper_imputation.R"))
source(paste0(helper.dir, "Helper/helper_causalInference.R"))
source(paste0(helper.dir, "Helper/helper_simulations.R"))
source(paste0(helper.dir, "Helper/helper_dataGeneration.R"))
source(paste0(helper.dir, "Helper/helper_dataGeneration_linear.R"))

# Define a directory for results and decide whether to save computed results there or not
rdata.dir <- "~/Documents/TraumaMatrix/CausalInference/Simulations/causal-inference-missing/results/"
fig.dir <- "~/Documents/TraumaMatrix/CausalInference/Simulations/causal-inference-missing/results/"
save_results <- FALSE

```

## Generate data

We will generate a simple toy data set with normally distributed confounders and
MCAR missing values.

For GRF to be consistent, we need to have at least one of cit/cio to be set to `TRUE`.

```{r choose_parameters}
n <- 5000
p <- 5
setting <- "linear1" # choose between linear1 and linear2
cit <- TRUE
cio <- FALSE 
prop.missing <- 0.3
seed <- 1234
tau <- 1

sample <- gen_linear(n=n, p=p, setting=setting,
                     tau=tau,
                     seed=seed, ps.dependence = "moderate", 
                     mechanism="MCAR", prop.missing=prop.missing,
                     cit=cit, cio=cio,
                     link="log-lin")
```

We generate the sample containing the complete confounders, the incomplete confounders,
the treatment assignment and observed outcome, and also
the propensity scores, the potential outcomes.

**Note: you can replace the chunk below with any dataset you wish to analyze. You have to
specify:**
- `X.na` 
- `W`
- `Y`

And set `synthetic=FALSE`

```{r generate_data}
synthetic <- TRUE

X <- data.frame(sample$X)

X.na <- data.frame(sample$X.incomp)
W <- sample$treat
Y <- sample$y

covariate_names <- colnames(X.na)
n <- dim(X.na)[1]
p <- dim(X.na)[2]

df <- data.frame(cbind(X, W=W, Y=Y))
colnames(df) <- c(covariate_names, "W", "Y")
df.na <- data.frame(cbind(X.na, W=W, Y=Y))
colnames(df.na) <- c(covariate_names, "W", "Y")
```

First we compute the unadjusted ATE, ignoring the confounders.

```{r unadjusted_ate}
ate_raw <- mean(Y[which(as.logical(W))]) - mean(Y[which(!as.logical(W))])
```

Let us also assess how the outcome is distributed with respect to the treatment group.

```{r} 
ggplot(data.frame(W=as.factor(W), Y=Y)) + 
  geom_histogram(aes(Y, color=W), fill = "white")
```


From these two variables we can compute the following observed probabilities:

```{r}
sprintf("Average outcome: %2.1f", mean(Y))
sprintf("P(Treatment=1) : %.2f", mean(W==1))
sprintf("E(Y | Treatment=1) : %.2f", mean(Y*(W==1))/mean(W==1))
sprintf("E(Y | Treatment=0) : %.2f", mean(Y*(W==0))/mean(W==0))
sprintf("ATE without adjustment : %.4f", ate_raw)
```


# Imputation

We impute the data with different methods (iterative FAMD, mice)


## Via principal components

In general settings, we don't know how the missing values are generated. So let's look at the matrix plot to identify if there are any variables that tend to be missing together or if we can detect any clear violation of the missing completely at random hypothesis:

```{r }
matrixplot(X.na, las=2, cex.axis = 0.3)
```

We do not observe any area predomently red that coincides with others that are particularly dark/light, that would make us suspect the MCAR hypothesis.

We can also run MCA on the missing and non missing entries to double check our conclusion and to check if other groups of variables tend to be missing together:
```{r }
data_miss <- data.frame(is.na(X.na))
data_miss <- apply(X=data_miss, FUN=function(x) if(x) "m" else "o", MARGIN=c(1,2))
res.mca <- MCA(data_miss, graph = FALSE)
plot(res.mca, invis = "ind", title = "MCA graph of the categories", cex =0.5)
```



We now perform a single imputation with a (regularized) iterative Factorial Analysis for Mixed Data model, which will allow imputation to take into account similarities between both individuals and relationships between variables. See: https://arxiv.org/pdf/1301.4797.pdf

```{r determine_type}
data.num <- sapply(df.na, is.numeric)
if (sum(data.num) == dim(df)[2]){
  type <- "pca"
} else if (sum(data.num) == 0) {
  type <- "mca"
} else {
  type <- "famd"
}
```

First we find the optimal number of dimensions for the imputation method by cross-validation.
```{r ncomp_all, eval=FALSE}
if (type == "pca"){
  ncomp <- estim_ncpPCA(df.na,
                        ncp.min = 1,
                        ncp.max=15,
                        method= "Regularized",
                        method.cv = "Kfold",
                        nbsim=10,
                        verbose = TRUE)
}
if (type == "mca"){
  ncomp <- estim_ncpMCA(df.na,
                        ncp.min = 1,
                        ncp.max=15,
                        method= "Regularized",
                        method.cv = "Kfold",
                        nbsim=10,
                        verbose = TRUE)
}
if (type == "famd"){
  ncomp <- estim_ncpFAMD(df.na,
                         ncp.min = 1,
                         ncp.max=15,
                         method= "Regularized",
                         method.cv = "Kfold",
                         nbsim=10,
                         verbose = TRUE)
}


if (save_results){
  save(ncomp,
       file = paste0(rdata.dir, Sys.Date(),"_ncomp_pc.RData"))
}
plot(1:length(ncomp$criterion), ncomp$criterion, xlab = "nb dim", ylab = "MSEP")
```


On this toy example, we do not run the above chunk to speed up the calculations.
We will arbitrarily set `ncp=3`.
```{r pc_impute}
ncp <- 3
df.imp.pc <- get_imputePC(df.na, seed = 0, ncp=ncp, Method = "Regularized", scale = T, threshold = 1e-06)

if (type=="pca"){
  res.pc <- PCA(df.imp.pc,
                  ncp = ncp, graph=F)
}
if (type=="mca"){
  res.pc <- MCA(df.imp.pc,
                ncp = ncp, graph=F)
}
if (type=="famd"){
  res.pc <- FAMD(df.imp.pc,
                 ncp = ncp, graph=F)
}
```

```{r save_famd, echo=F}
if (save_results){
  save(df.imp.pc, file = paste0(rdata.dir, Sys.Date(), "_df_imputed_pc.RData"))
}
```



## MICE

We also prepare a multiple imputation analysis, using the `mice` package. We impute the data `m=5` times.

```{r mice_impute}
df.imp.mice <- get_MICE(df.na, seed=0, m=5)
```


```{r save_mice, echo=F}
if (save_results){
  save(df.imp.mice, file = paste0(rdata.dir, Sys.Date(), "_df_imputed_mice.RData"))
}
```


# Balance plots


The standardized mean differences (SMD) higher than some threshold th, for instance th=0.1, indicate that the covariate distributions in the two groups differ: the treatment is not given uniformely at random. This explains the need for some adjustment or balancing in order to perform a causal analysis of the treatment on a certain outcome.




## On `X.imp.pc`
```{r balance_overlap_famd-grf, echo=F}
X.m = model.matrix(~. , data=data.frame(df.imp.pc[, covariate_names]))
forest.W = regression_forest(X.m, as.logical(W), tune.parameters = "all")
w.hat = predict(forest.W, X.m)$predictions
weights = as.numeric(as.logical(W))/w.hat + (1-as.numeric(as.logical(W)))/(1-w.hat)

balance <- bal.tab(df.imp.pc[, covariate_names], treat = W, 
                   estimand="ATE", continuous="std", weights = weights)

love.plot(x = balance, stat = "mean.diffs", abs = TRUE, var.order = "unadjusted", threshold = 0.1, cex=0.8)
```

We can also use the previously computed weights to look at the balance of the response pattern.
```{r balance_overlap_pc_mask-grf}
incomplete_confounders <- covariate_names[which(sapply(X.na, function(x) sum(is.na(x))>0))]
R <- data.frame(is.na(X.na[,incomplete_confounders]))
colnames(R) <- paste(incomplete_confounders, "_NA", sep="")
balance <- bal.tab(R, treat = W, estimand="ATE", weights = weights)

love.plot(x = balance, stat = "mean.diffs", abs = TRUE, var.order = "unadjusted", threshold = 0.1, cex=0.8)
```
```{r balance_overlap_famd_ps-grf}
bal.plot(x=data.frame(treat=as.logical(W), ps=w.hat, weights=weights), var.name = "ps", which = "both",
         treat=as.logical(W),
         weights=weights,
         type="histogram", mirror = TRUE)
```


## On `X.imp.mice`
```{r balance_overlap_mice-grf, echo=F}
w.hat <- list()
weights <- list()
df.ps <- list()
for (i in 1:length(df.imp.mice)){
  df.ps[[i]] <- df.imp.mice[[i]][, covariate_names]
  X.m = model.matrix(~. , data=data.frame(df.ps[[i]]))
  forest.W = regression_forest(X.m, as.logical(df.imp.mice[[i]]$W), tune.parameters = "all")
  w.hat[[i]] = predict(forest.W, X.m)$predictions
  weights[[i]] = as.numeric(as.logical(df.imp.mice[[i]]$W))/w.hat[[i]] + (1-as.numeric(as.logical(df.imp.mice[[i]]$W)))/(1-w.hat[[i]])
}
balance <- list()
for (i in 1:length(df.imp.mice)){
  balance[[i]] <- bal.tab(df.imp.mice[[i]][,covariate_names], 
                          treat = df.imp.mice[[i]]$W,
                          estimand="ATE",
                          continuous="std", 
                          weights=weights[[i]])
}

for (i in 1:length(df.imp.mice)){
  plt <- love.plot(x = balance[[i]], stat = "mean.diffs", abs = TRUE, var.order = "unadjusted", threshold = 0.1, cex=0.8)
  print(plt)
  
  plt <- bal.plot(x=data.frame(treat=as.logical(df.imp.mice[[i]]$W), ps=w.hat[[i]], weights=weights[[i]]), var.name = "ps", which = "both",
         treat=as.logical(df.imp.mice[[i]]$W),
         weights=weights[[i]],
         type = "histogram", mirror = TRUE)
  print(plt)
}
```

## On `X.na` using MIA
```{r balance_overlap_grf-mia, echo=FALSE}
na.action <- options()$na.action
options(na.action='na.pass')
X.m = model.matrix(~. , data=X.na)
options(na.action=na.action)
forest.W = regression_forest(X.m, as.logical(W), tune.parameters = "all")
w.hat = predict(forest.W, X.m)$predictions
weights = as.numeric(as.logical(W))/w.hat + (1-as.numeric(as.logical(W)))/(1-w.hat)

bal.plot(x=data.frame(treat=as.logical(W), ps=w.hat, weights=weights), 
         var.name = "ps", which = "both",
         treat=as.logical(W),
         weights=weights,
         type = "histogram", mirror = TRUE)

balance <- bal.tab(X.na, treat = W, estimand="ATE", continuous="std", weights = weights)
love.plot(x = balance, stat = "mean.diffs", abs = TRUE, var.order = "unadjusted", continuous="std", threshold = 0.1, cex=0.8, shapes=c("circle", "triangle"), colors=c(viridis::viridis(10)[3], viridis::viridis(10)[9]))

balance <- bal.tab(R, treat = W, estimand="ATE", weights = weights)

love.plot(x = balance, stat = "mean.diffs", abs = TRUE, var.order = "unadjusted", threshold = 0.1, cex=0.8, shapes=c("circle", "triangle"), colors=c(viridis::viridis(10)[3], viridis::viridis(10)[9]))
```






# ATE estimation

## IPW

### On imputed data
```{r ipw_ate, warning=FALSE, echo=F}
results_ipw_imp_list <- list()
results_ipw_imp <- data.frame(matrix(ncol=7, nrow=0), row.names = NULL)
colnames(results_ipw_imp) <- c("Estimand",
                               "Imputation.method", 
                               "PS.estimation",
                               "Mask",
                               "ATE.normalized", 
                               "STD.ATE.normalized",
                               "ATE.unnormalized")

data_list <- list(list("pc.imp", df.imp.pc),
                  list("mice", df.imp.mice))

methods_list <- list("glm", "grf.ate")

weights_list <- list("all", "treated", "control", "overlap")
weights_trim_list <- list(0.999, 0.999, 0.999, 1)
estimands_list <- list("ATE", "ATT", "ATC", "ATE_overlap")

idx <- 1

for (use.mask in c(FALSE, TRUE)){
  for (l in 1:length(weights_list)){
    for (i in 1:length(data_list)){
      if (data_list[[i]][[1]]=="mice"){
        confounders <- list()
        mask <- NULL
        outcome <- treatment <- list()
        if (use.mask) mask <- list()
        for (k in 1:length(data_list[[i]][[2]])){
          confounders[[k]] <- data_list[[i]][[2]][[k]] %>% 
                                dplyr::select(covariate_names)
    
  
          if (use.mask){
            mask[[k]] <- is.na(X.na[, covariate_names])
            mask[[k]] <- mask[[k]][,sapply(data.frame(mask[[k]] ), FUN = function(x) length(unique(x))==2)]
          }
        }
        
      }
        
      else {
        confounders <- data_list[[i]][[2]] %>% 
                          dplyr::select(covariate_names)
        
        mask <- NULL
        if (use.mask){
          mask <- is.na(X.na[, covariate_names])
          mask <- mask[,sapply(data.frame(mask), FUN = function(x) length(unique(x))==2)]
        }
       }
      
      
      
      for (j in 1:length(methods_list)){
        if (data_list[[i]][[1]]== "mice"){
          tmp <- c()
          for (k in 1:length(data_list[[i]][[2]])){
            tmp <- rbind(tmp, ipw(X=confounders[[k]], outcome = Y, treat = as.logical(W),
                                  mask = mask[[k]],
                                  ps.method = methods_list[[j]], 
                                  target = weights_list[[l]], 
                                  seed=seed, 
                                  trimming_weight=weights_trim_list[[l]]))
          }
          tmp[,3] <- tmp[,3]^2*n
          results_ipw_imp_list[[idx]] <- apply(tmp, 2, mean)
          results_ipw_imp_list[[idx]][[3]] <- sqrt(results_ipw_imp_list[[idx]][[3]] +
                                                (1+ 1/length(data_list[[i]][[2]]))*sum((tmp[,2] - results_ipw_imp_list[[idx]][[2]])^2)/(length(data_list[[i]][[2]])-1))/sqrt(n)
          
        }
        else {
          results_ipw_imp_list[[idx]] <- ipw(X=confounders, outcome = Y, treat = as.logical(W),
                                             mask = mask,
                                             ps.method = methods_list[[j]], target = weights_list[[l]], 
                                             seed=seed, trimming_weight=weights_trim_list[[l]])
          
        }
        results_ipw_imp <- rbind(results_ipw_imp,
                                   data.frame("Estimand" = estimands_list[[l]],
                                              "Imputation.method" = data_list[[i]][[1]],
                                              "PS.estimation" = methods_list[[j]],
                                              "Mask" = use.mask,
                                              "ATE.normalized" = results_ipw_imp_list[[idx]][[2]],
                                              "STD.ATE.normalized" = results_ipw_imp_list[[idx]][[3]],
                                              "ATE.unnormalized" = results_ipw_imp_list[[idx]][[1]]))
        idx <- idx+1
      }
    }
  }
}

knitr::kable(results_ipw_imp, caption = "IPW estimations", digits = 2)
```

### MIA+grf
```{r ipw_at_mia, warning=FALSE, echo=F}
results_ipw_mia_list <- list()
results_ipw_mia <- data.frame(matrix(ncol=7, nrow=0), row.names = NULL)
colnames(results_ipw_mia) <- c("Estimand",
                               "Imputation.method", 
                               "PS.estimation", 
                               "Mask",
                               "ATE.normalized", 
                               "STD.ATE.normalized",
                               "ATE.unnormalized")



weights_list <- list("all", "treated", "control", "overlap")
weights_trim_list <- list(0.999, 0.999, 0.999, 1)
estimands_list <- list("ATE", "ATT", "ATC", "ATE_overlap")

    
idx <- 1

for (use.mask in c(TRUE)){
  for (k in 1:length(weights_list)){
    confounders <- X.na %>%
              dplyr::select(covariate_names)
    
    mask <- NULL
    if (use.mask){
      mask <- is.na(X.na[, covariate_names])
    }
    
    results_ipw_mia_list[[idx]] <- ipw(X=confounders, ps.method="grf.ate", 
                                       mask=mask,
                                       treat=as.logical(W), outcome=Y, 
                                       target=weights_list[[k]], 
                                       seed=seed, 
                                       trimming_weight=weights_trim_list[[k]])
       
        
    results_ipw_mia <- rbind(results_ipw_mia,
                              data.frame("Estimand" = estimands_list[[k]],
                                         "Imputation.method" = "mia",
                                         "PS.estimation" = "grf.ate",
                                         "Mask" = use.mask,
                                         "ATE.normalized" = results_ipw_mia_list[[idx]][[2]],
                                         "STD.ATE.normalized" = results_ipw_mia_list[[idx]][[3]],
                                         "ATE.unnormalized" = results_ipw_mia_list[[idx]][[1]]))
        
    idx <- idx+1
  }
}

knitr::kable(results_ipw_mia, caption = "ipw ATE estimations on mia covariates", digits = 2)
```


## DR

### On imputed data
```{r dr_imp, warning=FALSE, echo=F}
results_dr_imp_list <- list()
results_dr_imp <- data.frame(matrix(ncol=6, nrow=0), row.names = NULL)
colnames(results_dr_imp) <- c("Estimand",
                              "Imputation.method", 
                              "PS.estimation",
                              "Mask",
                              "ATE", 
                              "STD")

data_list <- list(list("pc.imp", df.imp.pc),
                  list("mice", df.imp.mice))

methods_list <- list("glm.grf", "grf.ate")

weights_list <- list("all", "treated", "control", "overlap")
weights_trim_list <- list(0.999, 0.999, 0.999, 1)
estimands_list <- list("ATE", "ATT", "ATC", "ATE_overlap")

idx <- 1

for (use.mask in c(FALSE, TRUE)){
  for (l in 1:length(weights_list)){
    for (i in 1:length(data_list)){
      if (data_list[[i]][[1]]=="mice"){
        confounders <- list()
        mask <- NULL
        if (use.mask) mask <- list()
        for (k in 1:length(data_list[[i]][[2]])){
          confounders[[k]] <- data_list[[i]][[2]][[k]] %>% 
                                dplyr::select(covariate_names)
          if (use.mask){
            mask[[k]] <- is.na(X.na[,covariate_names])
            mask[[k]] <- data.frame(mask[[k]][,sapply(data.frame(mask[[k]]), FUN = function(x) length(unique(x))==2)])
          }
        }
      }
      
      else {    
        confounders <- data_list[[i]][[2]] %>% 
                          dplyr::select(covariate_names)
        mask <- NULL
        if (use.mask){
          mask <- is.na(X.na[,covariate_names])
          mask <- data.frame(mask[,sapply(data.frame(mask), FUN = function(x) length(unique(x))==2)])
        }
      }
      
      for (j in 1:length(methods_list)){
        if (data_list[[i]][[1]] == "mice"){
          tmp <- c()
          for (k in 1:length(data_list[[i]][[2]])){
            tmp <- rbind(tmp, dr(X=confounders[[k]], 
                                 outcome = Y, treat = as.logical(W),
                                 mask = mask[[k]],
                                 ps.method = methods_list[[j]], 
                                 out.method = methods_list[[j]],
                                 target = weights_list[[l]], 
                                 seed=seed, 
                                 trimming_weight=weights_trim_list[[l]])) 
          }
          tmp[,2] <- tmp[,2]^2*n
          results_dr_imp_list[[idx]] <- apply(tmp, 2, mean)
          results_dr_imp_list[[idx]][[2]] <- sqrt(results_dr_imp_list[[idx]][[2]] +
                                              (1+ 1/length(data_list[[i]][[2]]))*sum((tmp[,1] - results_dr_imp_list[[idx]][[1]])^2)/(length(data_list[[i]][[2]])-1))/sqrt(n)
        }
        else {
          results_dr_imp_list[[idx]] <- dr(X=confounders, 
                                           outcome = Y, treat = as.logical(W),
                                           mask = mask,
                                           ps.method = methods_list[[j]], 
                                           out.method = methods_list[[j]],
                                           target = weights_list[[l]], 
                                           seed=seed, 
                                           trimming_weight=weights_trim_list[[l]])
        }
        results_dr_imp <- rbind(results_dr_imp,
                                 data.frame("Estimand" = estimands_list[[l]],
                                            "Imputation.method" = data_list[[i]][[1]],
                                            "PS.estimation" = methods_list[[j]],
                                            "Mask" = use.mask,
                                            "ATE" = results_dr_imp_list[[idx]][[1]],
                                            "STD" = results_dr_imp_list[[idx]][[2]]))
        
        idx <- idx+1
      }
    }
  }
}
knitr::kable(results_dr_imp, caption = "DR estimations", digits = 2)
```

### MIA+grf
```{r dr_mia, warning=FALSE, echo=F}
results_dr_mia_list <- list()
results_dr_mia <- data.frame(matrix(ncol=6, nrow=0), row.names = NULL)
colnames(results_dr_mia) <- c("Estimand",
                              "Imputation.method",
                              "PS.estimation",
                              "Mask",
                              "ATE", 
                              "STD")

weights_list <- list("all", "treated", "control", "overlap")
weights_trim_list <- list(0.999, 0.999, 0.999, 1)
estimands_list <- list("ATE", "ATT", "ATC", "ATE_overlap")

    
idx <- 1

for (use.mask in c(FALSE, TRUE)){
  for (k in 1:length(weights_list)){
    confounders <- X.na %>%
                    dplyr::select(covariate_names) 
    mask <- NULL
    if (use.mask){
      mask <- is.na(X.na[,covariate_names])
      mask <- data.frame(mask[,sapply(data.frame(mask), FUN = function(x) length(unique(x))==2)])
    }
      
    results_dr_mia_list[[idx]] <- dr(X=confounders, 
                                     outcome=Y, treat=as.logical(W),
                                     mask = mask,
                                     ps.method = "grf.ate", out.method = "grf.ate",
                                     target = weights_list[[k]], 
                                     seed=seed, 
                                     trimming_weight=weights_trim_list[[k]])
         
          
    results_dr_mia <- rbind(results_dr_mia,
                            data.frame("Estimand" = estimands_list[[k]],
                                       "Imputation.method" = "mia",
                                       "PS.estimation" = "grf.ate",
                                       "Mask" = use.mask,
                                       "ATE" = results_dr_mia_list[[idx]][[1]],
                                       "STD" = results_dr_mia_list[[idx]][[2]]))
    
    idx <- idx+1
  }
}

knitr::kable(results_dr_mia, caption = "DR ATE estimations on mia covariates", digits = 2)
```


# Results
## Plots

We will plot the results for the ATE estimation. Alternatively, you can also plot the
results for the other estimands (in the call of the function `plot_treatment_effect`, set `estimand` to `ATT`, `ATC` or `ATE_overlap`).


```{r function_plot_combined, echo=F}
plot_treatment_effect <- function(res_dr, res_ipw, estimand, ps.estimation=c("grf", "grf.ate"), 
                                  imputation.method=c("pc.imp","mice","mia"),
                                  mask=TRUE){ 
  results_dr_ate <- res_dr %>%
                       filter(Estimand == estimand & PS.estimation %in% ps.estimation &
                              Mask == mask &
                              tolower(Imputation.method) %in% imputation.method)

  results_dr_ate$CI.inf<- results_dr_ate$ATE - 1.96*results_dr_ate$STD
  results_dr_ate$CI.sup <- results_dr_ate$ATE + 1.96*results_dr_ate$STD


  results_ipw_ate <- res_ipw %>%
                       filter(Estimand == estimand & PS.estimation %in% ps.estimation &
                              Mask == mask &
                              tolower(Imputation.method) %in% imputation.method) 
  
  results_ipw_ate$ATE <- results_ipw_ate$ATE.normalized
  results_ipw_ate$STD <- results_ipw_ate$STD.ATE.normalized
  
  results_ipw_ate$CI.inf <- results_ipw_ate$ATE - 1.96*results_ipw_ate$STD
  results_ipw_ate$CI.sup <- results_ipw_ate$ATE + 1.96*results_ipw_ate$STD


  results_ipw_ate <- dplyr::select(results_ipw_ate, -c("ATE.normalized","ATE.unnormalized",
                                                       "STD.ATE.normalized"))

  results_ate <- rbind(cbind(results_dr_ate, "type"=rep("dr", dim(results_dr_ate)[1])),
                       cbind(results_ipw_ate,"type"=rep("ipw", dim(results_ipw_ate)[1])))
  results_ate$type <- as.factor(results_ate$type)

  results_ate$PS.estimation[which(results_ate$PS.estimation=="glm.grf")] <- "glm"
  
  if ("grf" %in% ps.estimation & !("glm" %in% ps.estimation)){
    levels(results_ate$PS.estimation) <- rep("grf.ate", length(levels(results_ate$PS.estimation)))
  }
  results_ate$Imputation.set <- interaction(results_ate$Imputation.method,
                                            results_ate$PS.estimation)

  df_plot <- results_ate[which(tolower(results_ate$Imputation.method) %in% imputation.method),]
  y.min <- min(c(ate_raw, df_plot$CI.inf), na.rm=T)
  y.min <- if_else(y.min<0, y.min*1.1, y.min*0.9)
  y.max <- max(c(ate_raw, df_plot$CI.sup), na.rm=T)
  y.max <- if_else(y.max<0, y.max*0.9, y.max*1.1)

  labels <- c("mia.grf.ate" = "MIA",
              "mice.grf.ate" ="MICE",
              "pc.imp.grf.ate" ="PC imputation",
              "mean.grf.ate" = "Mean imputation",
              "mf.grf.ate" = "Latent factors",
              "mice.glm" ="MICE",
              "pc.imp.glm" ="PC imputation",
              "mean.glm" = "Mean imputation",
              "mf.glm" = "Latent factors",
              "mice.glm.grf" ="MICE",
              "pc.imp.glm.grf" ="PC imputation",
              "mean.glm.grf" = "Mean imputation",
              "mf.glm.grf" = "Latent factors")
  plt <- ggplot(data=df_plot,
         aes(x=Imputation.set, y = ATE, color=Imputation.method)) +
          geom_errorbar(aes(ymin=CI.inf, ymax=CI.sup, linetype = type), width=0.8, size=0.8)
  if (estimand == "ATE") {
    plt <- plt + geom_hline(aes(yintercept = ate_raw, colour = "ATE naive"), linetype = "dashed", size = 0.8)
  }
  if (synthetic & estimand == "ATE") {
    plt <- plt + geom_hline(aes(yintercept=tau, colour="ATE true"), show.legend = T)
  }
  plt <- plt + 
          coord_flip() +
          colScale +
          theme(axis.text=element_text(size=15),
                legend.position="bottom",
                legend.text=element_text(size=15),
                legend.title=element_text(size=15),
                axis.title.y=element_blank(),
                axis.text.y=element_blank(),
                axis.ticks.y=element_blank()) +
          scale_x_discrete(labels = labels[which(names(labels) %in% df_plot$Imputation.set)],
                           limits = names(labels)[which(names(labels) %in% df_plot$Imputation.set)],
                           position="top") +
    xlab("") +
    ylab(estimand) +
    ylim(c(y.min,y.max)) +
    labs(title=paste0(estimand," estimation"), cex=0.7)
  
  return(plt)
}
```


```{r combine_results, echo=F, warning = F, message = F}
# Aggregate IPW results
results_ipw <- rbind(results_ipw_imp,
                     results_ipw_mia)

levels(results_ipw$Imputation.method) <- tolower(levels(results_ipw$Imputation.method))

# Aggregate DR results
results_dr <- rbind(results_dr_imp,
                    results_dr_mia) 

if (save_results) {
  save(results_ipw, results_dr, file=paste0(rdata.dir, Sys.Date(), "_results_ipw_dr.RData"))
}
levels(results_dr$Imputation.method) <- tolower(levels(results_dr$Imputation.method))
```

### Nuisance parameter estimation via logistic and linear regressions

```{r plot_ate_glm, echo=F}
plt <- plot_treatment_effect(results_dr, results_ipw, "ATE", ps.estimation=c("glm", "glm.grf"))
print(plt)

if (save_results) {
  ggsave(paste0(fig.dir,Sys.Date(),"_ipw_dr_glm_ate.pdf"), 
         plot = last_plot(), 
         width=11, height=8.5)
} 
```

### Nuisance parameter estimation via random forest regressions

```{r plot_ate_grf, echo=F}
plt <- plot_treatment_effect(results_dr, results_ipw, "ATE", ps.estimation=c("grf", "grf.ate"))
print(plt) 

if (save_results) {
  ggsave(paste0(fig.dir,Sys.Date(),"_ipw_dr_grf_ate.pdf"),
         plot = last_plot(), 
         width=11, height=8.5)
}
```

## Table of all results
```{r table_results, echo=F, warning = F, message = F}
knitr::kable(results_ipw, caption = "IPW ATE estimations", digits = 2)
knitr::kable(results_dr, caption = "DR ATE estimations", digits = 2) 
```
